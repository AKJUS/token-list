name: Bump version on token changes
on:
  push:
    branches: [main]
    paths: ['chains/*.json']

jobs:
  version-bump:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Read .nvmrc
      run: echo "NVMRC=$(cat ./.nvmrc)" >> $GITHUB_OUTPUT
      id: nvm

    - name: Install pnpm
      uses: pnpm/action-setup@v4
      with:
        version: 10
    - name: Use Node + pnpm
      uses: actions/setup-node@v4
      with:
        node-version: "${{ steps.nvm.outputs.NVMRC }}"
        cache: "pnpm"

    - run: pnpm install --frozen-lockfile

    - name: Configure Git
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"

    - name: Check for token changes
      id: token_changes
      run: |
        if git diff --name-only HEAD~1 HEAD | grep -q "chains/.*\.json"; then
          echo "tokens_changed=true" >> $GITHUB_OUTPUT
          echo "Token files were modified in this commit"
        else
          echo "tokens_changed=false" >> $GITHUB_OUTPUT
          echo "No token files were modified"
        fi

    - name: Analyze token changes
      if: steps.token_changes.outputs.tokens_changed == 'true'
      id: analyze_changes
      run: |
        # Create a script to analyze changes in token files
        cat > analyze_changes.js << 'EOF'
        const fs = require('fs');
        const { execSync } = require('child_process');
        
        // Get list of changed files
        const changedFiles = execSync('git diff --name-only HEAD~1 HEAD', { encoding: 'utf8' })
          .split('\n')
          .filter(f => f.match(/chains\/.*\.json$/));
        
        const changes = [];
        
        for (const file of changedFiles) {
          try {
            // Check if file was added, modified, or deleted
            const status = execSync(`git diff --name-status HEAD~1 HEAD -- "${file}"`, { encoding: 'utf8' }).trim();
            
            if (status.startsWith('A')) {
              // File was added
              const after = JSON.parse(fs.readFileSync(file, 'utf8'));
              changes.push({ file, type: 'added', after });
            } else if (status.startsWith('D')) {
              // File was deleted
              const before = JSON.parse(execSync(`git show HEAD~1:"${file}"`, { encoding: 'utf8' }));
              changes.push({ file, type: 'deleted', before });
            } else if (status.startsWith('M')) {
              // File was modified
              const before = JSON.parse(execSync(`git show HEAD~1:"${file}"`, { encoding: 'utf8' }));
              const after = JSON.parse(fs.readFileSync(file, 'utf8'));
              changes.push({ file, type: 'modified', before, after });
            }
          } catch (e) {
            console.error(`Error analyzing ${file}:`, e.message);
          }
        }
        
        // Output base64-encoded changes for the build script
        const changesJson = JSON.stringify(changes);
        const changesBase64 = Buffer.from(changesJson).toString('base64');
        console.log('CHANGES_BASE64=' + changesBase64);
        EOF
        
        # Run the analysis and capture the output
        CHANGES_OUTPUT=$(node analyze_changes.js)
        echo "$CHANGES_OUTPUT" >> $GITHUB_OUTPUT

    - name: Increment version and build
      if: steps.token_changes.outputs.tokens_changed == 'true'
      run: |
        # Extract the base64 changes from the previous step
        CHANGES_BASE64="${{ steps.analyze_changes.outputs.CHANGES_BASE64 }}"
        
        # Run the build script with version increment flag and git changes
        pnpm build --increment-version --git-changes="$CHANGES_BASE64"

        # Check if files were actually changed by the build
        if git diff --quiet; then
          echo "No version changes were made"
          exit 0
        fi

        # Get the new version for commit message
        NEW_VERSION=$(node -p "JSON.parse(require('fs').readFileSync('base.tokenlist.json', 'utf8')).version.major + '.' + JSON.parse(require('fs').readFileSync('base.tokenlist.json', 'utf8')).version.minor + '.' + JSON.parse(require('fs').readFileSync('base.tokenlist.json', 'utf8')).version.patch")
        echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV

        # Stage the version changes
        git add base.tokenlist.json package.json

    - name: Commit version bump with verified signature
      if: steps.token_changes.outputs.tokens_changed == 'true'
      uses: swinton/commit@v2.0.0
      with:
        commit-message: "Auto-increment version to v${{ env.NEW_VERSION }} for token list update"

    - name: Create tag and push
      if: steps.token_changes.outputs.tokens_changed == 'true'
      run: |
        # Get the new version for tagging
        NEW_VERSION=$(node -p "JSON.parse(require('fs').readFileSync('base.tokenlist.json', 'utf8')).version.major + '.' + JSON.parse(require('fs').readFileSync('base.tokenlist.json', 'utf8')).version.minor + '.' + JSON.parse(require('fs').readFileSync('base.tokenlist.json', 'utf8')).version.patch")
        
        # Create a git tag
        git tag "v${NEW_VERSION}"

        # Push changes and tag
        git push origin main
        git push origin "v${NEW_VERSION}"
      env:
        FLEEK_PAT: ${{ secrets.FLEEK_PAT }}
        FLEEK_PROJECT_ID: ${{ secrets.FLEEK_PROJECT_ID }}

    - name: Upload token list as an artifact
      if: steps.token_changes.outputs.tokens_changed == 'true'
      uses: actions/upload-artifact@v4
      with:
        name: taho.tokenlist.json
        path: build/taho.tokenlist.json
